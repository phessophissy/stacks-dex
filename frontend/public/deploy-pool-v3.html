<!DOCTYPE html>
<html>
<head>
  <title>Deploy Pool V3</title>
  <style>
    body { font-family: system-ui; background: #1a1a2e; color: #eee; padding: 40px; max-width: 800px; margin: 0 auto; }
    h1 { color: #f7931a; }
    button { background: #f7931a; color: #000; border: none; padding: 15px 30px; font-size: 18px; cursor: pointer; border-radius: 8px; margin: 10px 5px; }
    button:hover { background: #ffa500; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    pre { background: #16213e; padding: 15px; border-radius: 8px; overflow-x: auto; font-size: 12px; max-height: 400px; overflow-y: auto; white-space: pre-wrap; word-wrap: break-word; }
    .status { padding: 15px; border-radius: 8px; margin: 15px 0; }
    .success { background: #1a4d2e; border: 1px solid #2ecc71; }
    .error { background: #4d1a1a; border: 1px solid #e74c3c; }
    .pending { background: #4d4d1a; border: 1px solid #f1c40f; }
    .info { background: #1a3d4d; padding: 15px; border-radius: 8px; margin: 15px 0; }
  </style>
</head>
<body>
  <h1>üöÄ Deploy Pool V3 Contract</h1>
  
  <div class="info">
    <h3>New Features in V3:</h3>
    <ul>
      <li>‚úÖ <strong>Bidirectional swaps</strong> - swap-x-for-y AND swap-y-for-x</li>
      <li>‚úÖ <strong>Skip fee transfer when sender == fee recipient</strong> - allows you to swap too!</li>
      <li>‚úÖ Track fees separately for X and Y tokens</li>
    </ul>
  </div>

  <button id="deployBtn">Deploy Pool V3 Contract</button>
  
  <div id="status"></div>
  <pre id="output">Click "Deploy Pool V3 Contract" to begin...</pre>

  <script>
    const CONTRACT_SOURCE = `;; STACKS DEX - Constant Product AMM Pool Contract V3 (Clarity 3)
;; Features: Bidirectional swaps, skip fee when sender == recipient

(use-trait ft-trait 'SP3FBR2AGK5H9QBDH3EEN6DF8EK8JY7RX8QJ5SVTE.sip-010-trait-ft-standard.sip-010-trait)

;; Fee configuration: 30 basis points = 0.30%
(define-constant FEE_BPS u30)
(define-constant BPS_DENOM u10000)

;; Error codes
(define-constant ERR_ZERO_INPUT (err u100))
(define-constant ERR_ZERO_RESERVES (err u101))
(define-constant ERR_DEADLINE_EXPIRED (err u102))
(define-constant ERR_SLIPPAGE_EXCEEDED (err u103))
(define-constant ERR_INSUFFICIENT_LIQUIDITY (err u104))
(define-constant ERR_TRANSFER_X_FAILED (err u105))
(define-constant ERR_TRANSFER_Y_FAILED (err u106))
(define-constant ERR_FEE_TRANSFER_FAILED (err u107))
(define-constant ERR_ALREADY_INITIALIZED (err u200))
(define-constant ERR_NOT_INITIALIZED (err u201))

;; State variables
(define-data-var fee-recipient (optional principal) none)
(define-data-var reserve-x uint u0)
(define-data-var reserve-y uint u0)
(define-data-var total-fees-x uint u0)
(define-data-var total-fees-y uint u0)

;; Read-only functions
(define-read-only (get-reserves)
  { x: (var-get reserve-x), y: (var-get reserve-y) })

(define-read-only (get-fee-info)
  { fee-bps: FEE_BPS, denom: BPS_DENOM, recipient: (var-get fee-recipient) })

(define-read-only (get-total-fees)
  { fees-x: (var-get total-fees-x), fees-y: (var-get total-fees-y) })

(define-read-only (quote-x-for-y (dx uint))
  (let ((rx (var-get reserve-x)) (ry (var-get reserve-y)))
    (asserts! (> dx u0) ERR_ZERO_INPUT)
    (asserts! (and (> rx u0) (> ry u0)) ERR_ZERO_RESERVES)
    (let ((fee (/ (* dx FEE_BPS) BPS_DENOM))
          (dx-to-pool (- dx fee))
          (dy (/ (* ry dx-to-pool) (+ rx dx-to-pool))))
      (asserts! (< dy ry) ERR_INSUFFICIENT_LIQUIDITY)
      (ok { dy: dy, fee: fee }))))

(define-read-only (quote-y-for-x (dy uint))
  (let ((rx (var-get reserve-x)) (ry (var-get reserve-y)))
    (asserts! (> dy u0) ERR_ZERO_INPUT)
    (asserts! (and (> rx u0) (> ry u0)) ERR_ZERO_RESERVES)
    (let ((fee (/ (* dy FEE_BPS) BPS_DENOM))
          (dy-to-pool (- dy fee))
          (dx (/ (* rx dy-to-pool) (+ ry dy-to-pool))))
      (asserts! (< dx rx) ERR_INSUFFICIENT_LIQUIDITY)
      (ok { dx: dx, fee: fee }))))

(define-read-only (calculate-fee (amount uint))
  (/ (* amount FEE_BPS) BPS_DENOM))

;; Swap X for Y (e.g., ALEX -> USDA)
(define-public (swap-x-for-y 
    (token-x <ft-trait>)
    (token-y <ft-trait>)
    (dx uint)
    (min-dy uint)
    (recipient principal)
    (deadline uint))
  (let ((rx (var-get reserve-x))
        (ry (var-get reserve-y))
        (sender tx-sender)
        (fee-addr (unwrap! (var-get fee-recipient) ERR_NOT_INITIALIZED)))
    (asserts! (<= stacks-block-height deadline) ERR_DEADLINE_EXPIRED)
    (asserts! (> dx u0) ERR_ZERO_INPUT)
    (asserts! (and (> rx u0) (> ry u0)) ERR_ZERO_RESERVES)
    (let ((fee (/ (* dx FEE_BPS) BPS_DENOM))
          (dx-to-pool (- dx fee))
          (dy (/ (* ry dx-to-pool) (+ rx dx-to-pool))))
      (asserts! (>= dy min-dy) ERR_SLIPPAGE_EXCEEDED)
      (asserts! (< dy ry) ERR_INSUFFICIENT_LIQUIDITY)
      ;; Transfer fee only if sender != fee recipient (skip self-transfer)
      (if (and (> fee u0) (not (is-eq sender fee-addr)))
        (unwrap! (contract-call? token-x transfer fee sender fee-addr none) ERR_FEE_TRANSFER_FAILED)
        true)
      ;; Transfer input tokens to pool
      (unwrap! (contract-call? token-x transfer dx-to-pool sender (as-contract tx-sender) none) ERR_TRANSFER_X_FAILED)
      ;; Transfer output tokens to recipient
      (unwrap! (as-contract (contract-call? token-y transfer dy tx-sender recipient none)) ERR_TRANSFER_Y_FAILED)
      ;; Update reserves
      (var-set reserve-x (+ rx dx-to-pool))
      (var-set reserve-y (- ry dy))
      ;; Track fees (even if not transferred for self-swaps)
      (var-set total-fees-x (+ (var-get total-fees-x) fee))
      (ok { dx: dx, dy: dy, fee: fee, recipient: recipient }))))

;; Swap Y for X (e.g., USDA -> ALEX)
(define-public (swap-y-for-x 
    (token-x <ft-trait>)
    (token-y <ft-trait>)
    (dy uint)
    (min-dx uint)
    (recipient principal)
    (deadline uint))
  (let ((rx (var-get reserve-x))
        (ry (var-get reserve-y))
        (sender tx-sender)
        (fee-addr (unwrap! (var-get fee-recipient) ERR_NOT_INITIALIZED)))
    (asserts! (<= stacks-block-height deadline) ERR_DEADLINE_EXPIRED)
    (asserts! (> dy u0) ERR_ZERO_INPUT)
    (asserts! (and (> rx u0) (> ry u0)) ERR_ZERO_RESERVES)
    (let ((fee (/ (* dy FEE_BPS) BPS_DENOM))
          (dy-to-pool (- dy fee))
          (dx (/ (* rx dy-to-pool) (+ ry dy-to-pool))))
      (asserts! (>= dx min-dx) ERR_SLIPPAGE_EXCEEDED)
      (asserts! (< dx rx) ERR_INSUFFICIENT_LIQUIDITY)
      ;; Transfer fee only if sender != fee recipient (skip self-transfer)
      (if (and (> fee u0) (not (is-eq sender fee-addr)))
        (unwrap! (contract-call? token-y transfer fee sender fee-addr none) ERR_FEE_TRANSFER_FAILED)
        true)
      ;; Transfer input tokens to pool
      (unwrap! (contract-call? token-y transfer dy-to-pool sender (as-contract tx-sender) none) ERR_TRANSFER_Y_FAILED)
      ;; Transfer output tokens to recipient
      (unwrap! (as-contract (contract-call? token-x transfer dx tx-sender recipient none)) ERR_TRANSFER_X_FAILED)
      ;; Update reserves
      (var-set reserve-x (- rx dx))
      (var-set reserve-y (+ ry dy-to-pool))
      ;; Track fees
      (var-set total-fees-y (+ (var-get total-fees-y) fee))
      (ok { dx: dx, dy: dy, fee: fee, recipient: recipient }))))

;; Initialize pool with initial liquidity
(define-public (initialize-pool 
    (token-x <ft-trait>)
    (token-y <ft-trait>)
    (amount-x uint)
    (amount-y uint))
  (begin
    (asserts! (and (is-eq (var-get reserve-x) u0) (is-eq (var-get reserve-y) u0)) ERR_ALREADY_INITIALIZED)
    (var-set fee-recipient (some tx-sender))
    (unwrap! (contract-call? token-x transfer amount-x tx-sender (as-contract tx-sender) none) ERR_TRANSFER_X_FAILED)
    (unwrap! (contract-call? token-y transfer amount-y tx-sender (as-contract tx-sender) none) ERR_TRANSFER_Y_FAILED)
    (var-set reserve-x amount-x)
    (var-set reserve-y amount-y)
    (ok { x: amount-x, y: amount-y, fee-recipient: tx-sender })))

;; Contract info
(define-read-only (get-contract-info)
  { 
    name: "stacks-dex-pool-v3", 
    version: "3.0.0", 
    fee-bps: FEE_BPS, 
    fee-recipient: (var-get fee-recipient), 
    reserve-x: (var-get reserve-x), 
    reserve-y: (var-get reserve-y), 
    total-fees-x: (var-get total-fees-x),
    total-fees-y: (var-get total-fees-y)
  })`;

    const statusEl = document.getElementById('status');
    const outputEl = document.getElementById('output');
    const deployBtn = document.getElementById('deployBtn');

    deployBtn.addEventListener('click', async function() {
      outputEl.textContent = 'Starting deployment...\n';
      
      // Check for Leather wallet
      if (!window.LeatherProvider) {
        statusEl.innerHTML = '<div class="status error">‚ùå Leather wallet not found. Please install it from leather.io</div>';
        outputEl.textContent += 'ERROR: Leather wallet extension not detected.\n';
        return;
      }
      
      outputEl.textContent += '‚úì Leather wallet detected\n';
      statusEl.innerHTML = '<div class="status pending">Connecting to wallet...</div>';

      try {
        // Get addresses from Leather
        outputEl.textContent += 'Requesting wallet addresses...\n';
        const addressResponse = await window.LeatherProvider.request('getAddresses');
        console.log('Address response:', addressResponse);
        
        const stacksAddress = addressResponse.result.addresses.find(function(a) {
          return a.type === 'stacks' || (a.address && (a.address.startsWith('SP') || a.address.startsWith('SM')));
        });
        
        if (!stacksAddress) {
          throw new Error('No Stacks address found in wallet');
        }

        const senderAddress = stacksAddress.address;
        outputEl.textContent += '‚úì Connected: ' + senderAddress + '\n\n';

        statusEl.innerHTML = '<div class="status pending">Please confirm contract deployment in Leather wallet...</div>';
        outputEl.textContent += 'Sending deployment request to Leather...\n';
        outputEl.textContent += '(A popup should appear - please confirm the transaction)\n\n';

        // Use Leather's stx_deployContract method
        const deployResponse = await window.LeatherProvider.request('stx_deployContract', {
          name: 'pool-v3',
          clarityCode: CONTRACT_SOURCE,
          clarityVersion: '3',
          network: 'mainnet',
          fee: 500000,
        });

        console.log('Deploy response:', deployResponse);

        if (deployResponse.result && deployResponse.result.txid) {
          const txId = deployResponse.result.txid;
          statusEl.innerHTML = '<div class="status success">‚úÖ Contract deployment submitted!</div>';
          outputEl.textContent += '\n‚úÖ SUCCESS!\n';
          outputEl.textContent += 'Transaction ID: ' + txId + '\n';
          outputEl.textContent += 'Contract: ' + senderAddress + '.pool-v3\n\n';
          outputEl.textContent += 'View on explorer:\nhttps://explorer.hiro.so/txid/' + txId + '?chain=mainnet\n\n';
          outputEl.textContent += '‚è≥ Wait for the transaction to confirm before initializing the pool.';
        } else {
          throw new Error('No transaction ID in response: ' + JSON.stringify(deployResponse));
        }

      } catch (error) {
        console.error('Deploy error:', error);
        
        if (error.code === 4001 || (error.message && error.message.includes('User rejected'))) {
          statusEl.innerHTML = '<div class="status error">Deployment cancelled by user</div>';
          outputEl.textContent += '\n‚ùå Deployment cancelled\n';
        } else {
          statusEl.innerHTML = '<div class="status error">Error: ' + (error.message || 'Unknown error') + '</div>';
          outputEl.textContent += '\n‚ùå Error: ' + (error.message || JSON.stringify(error)) + '\n';
        }
      }
    });

    console.log('Deploy page ready - using Leather Provider directly');
  </script>
</body>
</html>
